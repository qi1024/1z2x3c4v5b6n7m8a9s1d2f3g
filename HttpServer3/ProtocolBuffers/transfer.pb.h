// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: transfer.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_transfer_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_transfer_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[3]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_transfer_2eproto;
namespace transfer {
class File;
struct FileDefaultTypeInternal;
extern FileDefaultTypeInternal _File_default_instance_;
class Record;
struct RecordDefaultTypeInternal;
extern RecordDefaultTypeInternal _Record_default_instance_;
class User;
struct UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
}  // namespace transfer
PROTOBUF_NAMESPACE_OPEN
template<> ::transfer::File* Arena::CreateMaybeMessage<::transfer::File>(Arena*);
template<> ::transfer::Record* Arena::CreateMaybeMessage<::transfer::Record>(Arena*);
template<> ::transfer::User* Arena::CreateMaybeMessage<::transfer::User>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace transfer {

// ===================================================================

class User final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.User) */ {
 public:
  inline User() : User(nullptr) {}
  ~User() override;
  explicit constexpr User(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  User(const User& from);
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  inline User& operator=(User&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const User& default_instance() {
    return *internal_default_instance();
  }
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }
  inline void Swap(User* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(User* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  User* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<User>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const User& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const User& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.User";
  }
  protected:
  explicit User(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kPasswordFieldNumber = 3,
    kStatusFieldNumber = 4,
    kNicknameFieldNumber = 5,
    kCreateTimeFieldNumber = 6,
    kUserIDFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string password = 3;
  void clear_password();
  const std::string& password() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_password(ArgT0&& arg0, ArgT... args);
  std::string* mutable_password();
  PROTOBUF_NODISCARD std::string* release_password();
  void set_allocated_password(std::string* password);
  private:
  const std::string& _internal_password() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_password(const std::string& value);
  std::string* _internal_mutable_password();
  public:

  // string status = 4;
  void clear_status();
  const std::string& status() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_status(ArgT0&& arg0, ArgT... args);
  std::string* mutable_status();
  PROTOBUF_NODISCARD std::string* release_status();
  void set_allocated_status(std::string* status);
  private:
  const std::string& _internal_status() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_status(const std::string& value);
  std::string* _internal_mutable_status();
  public:

  // string nickname = 5;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string createTime = 6;
  void clear_createtime();
  const std::string& createtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_createtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_createtime();
  PROTOBUF_NODISCARD std::string* release_createtime();
  void set_allocated_createtime(std::string* createtime);
  private:
  const std::string& _internal_createtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_createtime(const std::string& value);
  std::string* _internal_mutable_createtime();
  public:

  // int32 userID = 1;
  void clear_userid();
  int32_t userid() const;
  void set_userid(int32_t value);
  private:
  int32_t _internal_userid() const;
  void _internal_set_userid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:transfer.User)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr password_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr status_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr createtime_;
  int32_t userid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class File final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.File) */ {
 public:
  inline File() : File(nullptr) {}
  ~File() override;
  explicit constexpr File(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  File(const File& from);
  File(File&& from) noexcept
    : File() {
    *this = ::std::move(from);
  }

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }
  inline File& operator=(File&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const File& default_instance() {
    return *internal_default_instance();
  }
  static inline const File* internal_default_instance() {
    return reinterpret_cast<const File*>(
               &_File_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(File& a, File& b) {
    a.Swap(&b);
  }
  inline void Swap(File* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(File* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  File* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<File>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const File& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const File& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(File* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.File";
  }
  protected:
  explicit File(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFileCodeFieldNumber = 3,
    kFileNameFieldNumber = 4,
    kFilePathFieldNumber = 5,
    kUploadTimeFieldNumber = 6,
    kFileSizeFieldNumber = 2,
    kFileIDFieldNumber = 1,
  };
  // string fileCode = 3;
  void clear_filecode();
  const std::string& filecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filecode();
  PROTOBUF_NODISCARD std::string* release_filecode();
  void set_allocated_filecode(std::string* filecode);
  private:
  const std::string& _internal_filecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filecode(const std::string& value);
  std::string* _internal_mutable_filecode();
  public:

  // bytes fileName = 4;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // bytes filePath = 5;
  void clear_filepath();
  const std::string& filepath() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filepath(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filepath();
  PROTOBUF_NODISCARD std::string* release_filepath();
  void set_allocated_filepath(std::string* filepath);
  private:
  const std::string& _internal_filepath() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filepath(const std::string& value);
  std::string* _internal_mutable_filepath();
  public:

  // string uploadTime = 6;
  void clear_uploadtime();
  const std::string& uploadtime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_uploadtime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_uploadtime();
  PROTOBUF_NODISCARD std::string* release_uploadtime();
  void set_allocated_uploadtime(std::string* uploadtime);
  private:
  const std::string& _internal_uploadtime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_uploadtime(const std::string& value);
  std::string* _internal_mutable_uploadtime();
  public:

  // uint64 fileSize = 2;
  void clear_filesize();
  uint64_t filesize() const;
  void set_filesize(uint64_t value);
  private:
  uint64_t _internal_filesize() const;
  void _internal_set_filesize(uint64_t value);
  public:

  // int32 fileID = 1;
  void clear_fileid();
  int32_t fileid() const;
  void set_fileid(int32_t value);
  private:
  int32_t _internal_fileid() const;
  void _internal_set_fileid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:transfer.File)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filecode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filepath_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr uploadtime_;
  uint64_t filesize_;
  int32_t fileid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// -------------------------------------------------------------------

class Record final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:transfer.Record) */ {
 public:
  inline Record() : Record(nullptr) {}
  ~Record() override;
  explicit constexpr Record(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Record(const Record& from);
  Record(Record&& from) noexcept
    : Record() {
    *this = ::std::move(from);
  }

  inline Record& operator=(const Record& from) {
    CopyFrom(from);
    return *this;
  }
  inline Record& operator=(Record&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Record& default_instance() {
    return *internal_default_instance();
  }
  static inline const Record* internal_default_instance() {
    return reinterpret_cast<const Record*>(
               &_Record_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(Record& a, Record& b) {
    a.Swap(&b);
  }
  inline void Swap(Record* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Record* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  Record* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<Record>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Record& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Record& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Record* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "transfer.Record";
  }
  protected:
  explicit Record(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 2,
    kOperationFieldNumber = 3,
    kTargetAccountFieldNumber = 4,
    kNicknameFieldNumber = 5,
    kFileNameFieldNumber = 6,
    kFileCodeFieldNumber = 8,
    kOperateTimeFieldNumber = 9,
    kFileSizeFieldNumber = 7,
    kRecordIDFieldNumber = 1,
  };
  // string account = 2;
  void clear_account();
  const std::string& account() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_account(ArgT0&& arg0, ArgT... args);
  std::string* mutable_account();
  PROTOBUF_NODISCARD std::string* release_account();
  void set_allocated_account(std::string* account);
  private:
  const std::string& _internal_account() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_account(const std::string& value);
  std::string* _internal_mutable_account();
  public:

  // string operation = 3;
  void clear_operation();
  const std::string& operation() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operation(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operation();
  PROTOBUF_NODISCARD std::string* release_operation();
  void set_allocated_operation(std::string* operation);
  private:
  const std::string& _internal_operation() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operation(const std::string& value);
  std::string* _internal_mutable_operation();
  public:

  // string targetAccount = 4;
  void clear_targetaccount();
  const std::string& targetaccount() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_targetaccount(ArgT0&& arg0, ArgT... args);
  std::string* mutable_targetaccount();
  PROTOBUF_NODISCARD std::string* release_targetaccount();
  void set_allocated_targetaccount(std::string* targetaccount);
  private:
  const std::string& _internal_targetaccount() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_targetaccount(const std::string& value);
  std::string* _internal_mutable_targetaccount();
  public:

  // string nickname = 5;
  void clear_nickname();
  const std::string& nickname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nickname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nickname();
  PROTOBUF_NODISCARD std::string* release_nickname();
  void set_allocated_nickname(std::string* nickname);
  private:
  const std::string& _internal_nickname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nickname(const std::string& value);
  std::string* _internal_mutable_nickname();
  public:

  // string fileName = 6;
  void clear_filename();
  const std::string& filename() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filename(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filename();
  PROTOBUF_NODISCARD std::string* release_filename();
  void set_allocated_filename(std::string* filename);
  private:
  const std::string& _internal_filename() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filename(const std::string& value);
  std::string* _internal_mutable_filename();
  public:

  // string fileCode = 8;
  void clear_filecode();
  const std::string& filecode() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_filecode(ArgT0&& arg0, ArgT... args);
  std::string* mutable_filecode();
  PROTOBUF_NODISCARD std::string* release_filecode();
  void set_allocated_filecode(std::string* filecode);
  private:
  const std::string& _internal_filecode() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_filecode(const std::string& value);
  std::string* _internal_mutable_filecode();
  public:

  // string operateTime = 9;
  void clear_operatetime();
  const std::string& operatetime() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_operatetime(ArgT0&& arg0, ArgT... args);
  std::string* mutable_operatetime();
  PROTOBUF_NODISCARD std::string* release_operatetime();
  void set_allocated_operatetime(std::string* operatetime);
  private:
  const std::string& _internal_operatetime() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_operatetime(const std::string& value);
  std::string* _internal_mutable_operatetime();
  public:

  // uint64 fileSize = 7;
  void clear_filesize();
  uint64_t filesize() const;
  void set_filesize(uint64_t value);
  private:
  uint64_t _internal_filesize() const;
  void _internal_set_filesize(uint64_t value);
  public:

  // int32 recordID = 1;
  void clear_recordid();
  int32_t recordid() const;
  void set_recordid(int32_t value);
  private:
  int32_t _internal_recordid() const;
  void _internal_set_recordid(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:transfer.Record)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr account_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operation_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr targetaccount_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nickname_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filename_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr filecode_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr operatetime_;
  uint64_t filesize_;
  int32_t recordid_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_transfer_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// int32 userID = 1;
inline void User::clear_userid() {
  userid_ = 0;
}
inline int32_t User::_internal_userid() const {
  return userid_;
}
inline int32_t User::userid() const {
  // @@protoc_insertion_point(field_get:transfer.User.userID)
  return _internal_userid();
}
inline void User::_internal_set_userid(int32_t value) {
  
  userid_ = value;
}
inline void User::set_userid(int32_t value) {
  _internal_set_userid(value);
  // @@protoc_insertion_point(field_set:transfer.User.userID)
}

// string account = 2;
inline void User::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& User::account() const {
  // @@protoc_insertion_point(field_get:transfer.User.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.User.account)
}
inline std::string* User::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:transfer.User.account)
  return _s;
}
inline const std::string& User::_internal_account() const {
  return account_.Get();
}
inline void User::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_account() {
  // @@protoc_insertion_point(field_release:transfer.User.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.User.account)
}

// string password = 3;
inline void User::clear_password() {
  password_.ClearToEmpty();
}
inline const std::string& User::password() const {
  // @@protoc_insertion_point(field_get:transfer.User.password)
  return _internal_password();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_password(ArgT0&& arg0, ArgT... args) {
 
 password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.User.password)
}
inline std::string* User::mutable_password() {
  std::string* _s = _internal_mutable_password();
  // @@protoc_insertion_point(field_mutable:transfer.User.password)
  return _s;
}
inline const std::string& User::_internal_password() const {
  return password_.Get();
}
inline void User::_internal_set_password(const std::string& value) {
  
  password_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_password() {
  
  return password_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_password() {
  // @@protoc_insertion_point(field_release:transfer.User.password)
  return password_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_password(std::string* password) {
  if (password != nullptr) {
    
  } else {
    
  }
  password_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), password,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (password_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    password_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.User.password)
}

// string status = 4;
inline void User::clear_status() {
  status_.ClearToEmpty();
}
inline const std::string& User::status() const {
  // @@protoc_insertion_point(field_get:transfer.User.status)
  return _internal_status();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_status(ArgT0&& arg0, ArgT... args) {
 
 status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.User.status)
}
inline std::string* User::mutable_status() {
  std::string* _s = _internal_mutable_status();
  // @@protoc_insertion_point(field_mutable:transfer.User.status)
  return _s;
}
inline const std::string& User::_internal_status() const {
  return status_.Get();
}
inline void User::_internal_set_status(const std::string& value) {
  
  status_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_status() {
  
  return status_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_status() {
  // @@protoc_insertion_point(field_release:transfer.User.status)
  return status_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_status(std::string* status) {
  if (status != nullptr) {
    
  } else {
    
  }
  status_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), status,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (status_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    status_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.User.status)
}

// string nickname = 5;
inline void User::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& User::nickname() const {
  // @@protoc_insertion_point(field_get:transfer.User.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.User.nickname)
}
inline std::string* User::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:transfer.User.nickname)
  return _s;
}
inline const std::string& User::_internal_nickname() const {
  return nickname_.Get();
}
inline void User::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_nickname() {
  // @@protoc_insertion_point(field_release:transfer.User.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.User.nickname)
}

// string createTime = 6;
inline void User::clear_createtime() {
  createtime_.ClearToEmpty();
}
inline const std::string& User::createtime() const {
  // @@protoc_insertion_point(field_get:transfer.User.createTime)
  return _internal_createtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void User::set_createtime(ArgT0&& arg0, ArgT... args) {
 
 createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.User.createTime)
}
inline std::string* User::mutable_createtime() {
  std::string* _s = _internal_mutable_createtime();
  // @@protoc_insertion_point(field_mutable:transfer.User.createTime)
  return _s;
}
inline const std::string& User::_internal_createtime() const {
  return createtime_.Get();
}
inline void User::_internal_set_createtime(const std::string& value) {
  
  createtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* User::_internal_mutable_createtime() {
  
  return createtime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* User::release_createtime() {
  // @@protoc_insertion_point(field_release:transfer.User.createTime)
  return createtime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void User::set_allocated_createtime(std::string* createtime) {
  if (createtime != nullptr) {
    
  } else {
    
  }
  createtime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), createtime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (createtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    createtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.User.createTime)
}

// -------------------------------------------------------------------

// File

// int32 fileID = 1;
inline void File::clear_fileid() {
  fileid_ = 0;
}
inline int32_t File::_internal_fileid() const {
  return fileid_;
}
inline int32_t File::fileid() const {
  // @@protoc_insertion_point(field_get:transfer.File.fileID)
  return _internal_fileid();
}
inline void File::_internal_set_fileid(int32_t value) {
  
  fileid_ = value;
}
inline void File::set_fileid(int32_t value) {
  _internal_set_fileid(value);
  // @@protoc_insertion_point(field_set:transfer.File.fileID)
}

// uint64 fileSize = 2;
inline void File::clear_filesize() {
  filesize_ = uint64_t{0u};
}
inline uint64_t File::_internal_filesize() const {
  return filesize_;
}
inline uint64_t File::filesize() const {
  // @@protoc_insertion_point(field_get:transfer.File.fileSize)
  return _internal_filesize();
}
inline void File::_internal_set_filesize(uint64_t value) {
  
  filesize_ = value;
}
inline void File::set_filesize(uint64_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:transfer.File.fileSize)
}

// string fileCode = 3;
inline void File::clear_filecode() {
  filecode_.ClearToEmpty();
}
inline const std::string& File::filecode() const {
  // @@protoc_insertion_point(field_get:transfer.File.fileCode)
  return _internal_filecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_filecode(ArgT0&& arg0, ArgT... args) {
 
 filecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.File.fileCode)
}
inline std::string* File::mutable_filecode() {
  std::string* _s = _internal_mutable_filecode();
  // @@protoc_insertion_point(field_mutable:transfer.File.fileCode)
  return _s;
}
inline const std::string& File::_internal_filecode() const {
  return filecode_.Get();
}
inline void File::_internal_set_filecode(const std::string& value) {
  
  filecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_filecode() {
  
  return filecode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* File::release_filecode() {
  // @@protoc_insertion_point(field_release:transfer.File.fileCode)
  return filecode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void File::set_allocated_filecode(std::string* filecode) {
  if (filecode != nullptr) {
    
  } else {
    
  }
  filecode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filecode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filecode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filecode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.File.fileCode)
}

// bytes fileName = 4;
inline void File::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& File::filename() const {
  // @@protoc_insertion_point(field_get:transfer.File.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.File.fileName)
}
inline std::string* File::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:transfer.File.fileName)
  return _s;
}
inline const std::string& File::_internal_filename() const {
  return filename_.Get();
}
inline void File::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* File::release_filename() {
  // @@protoc_insertion_point(field_release:transfer.File.fileName)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void File::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.File.fileName)
}

// bytes filePath = 5;
inline void File::clear_filepath() {
  filepath_.ClearToEmpty();
}
inline const std::string& File::filepath() const {
  // @@protoc_insertion_point(field_get:transfer.File.filePath)
  return _internal_filepath();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_filepath(ArgT0&& arg0, ArgT... args) {
 
 filepath_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.File.filePath)
}
inline std::string* File::mutable_filepath() {
  std::string* _s = _internal_mutable_filepath();
  // @@protoc_insertion_point(field_mutable:transfer.File.filePath)
  return _s;
}
inline const std::string& File::_internal_filepath() const {
  return filepath_.Get();
}
inline void File::_internal_set_filepath(const std::string& value) {
  
  filepath_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_filepath() {
  
  return filepath_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* File::release_filepath() {
  // @@protoc_insertion_point(field_release:transfer.File.filePath)
  return filepath_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void File::set_allocated_filepath(std::string* filepath) {
  if (filepath != nullptr) {
    
  } else {
    
  }
  filepath_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filepath,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filepath_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filepath_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.File.filePath)
}

// string uploadTime = 6;
inline void File::clear_uploadtime() {
  uploadtime_.ClearToEmpty();
}
inline const std::string& File::uploadtime() const {
  // @@protoc_insertion_point(field_get:transfer.File.uploadTime)
  return _internal_uploadtime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void File::set_uploadtime(ArgT0&& arg0, ArgT... args) {
 
 uploadtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.File.uploadTime)
}
inline std::string* File::mutable_uploadtime() {
  std::string* _s = _internal_mutable_uploadtime();
  // @@protoc_insertion_point(field_mutable:transfer.File.uploadTime)
  return _s;
}
inline const std::string& File::_internal_uploadtime() const {
  return uploadtime_.Get();
}
inline void File::_internal_set_uploadtime(const std::string& value) {
  
  uploadtime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* File::_internal_mutable_uploadtime() {
  
  return uploadtime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* File::release_uploadtime() {
  // @@protoc_insertion_point(field_release:transfer.File.uploadTime)
  return uploadtime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void File::set_allocated_uploadtime(std::string* uploadtime) {
  if (uploadtime != nullptr) {
    
  } else {
    
  }
  uploadtime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), uploadtime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (uploadtime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    uploadtime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.File.uploadTime)
}

// -------------------------------------------------------------------

// Record

// int32 recordID = 1;
inline void Record::clear_recordid() {
  recordid_ = 0;
}
inline int32_t Record::_internal_recordid() const {
  return recordid_;
}
inline int32_t Record::recordid() const {
  // @@protoc_insertion_point(field_get:transfer.Record.recordID)
  return _internal_recordid();
}
inline void Record::_internal_set_recordid(int32_t value) {
  
  recordid_ = value;
}
inline void Record::set_recordid(int32_t value) {
  _internal_set_recordid(value);
  // @@protoc_insertion_point(field_set:transfer.Record.recordID)
}

// string account = 2;
inline void Record::clear_account() {
  account_.ClearToEmpty();
}
inline const std::string& Record::account() const {
  // @@protoc_insertion_point(field_get:transfer.Record.account)
  return _internal_account();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_account(ArgT0&& arg0, ArgT... args) {
 
 account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.account)
}
inline std::string* Record::mutable_account() {
  std::string* _s = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:transfer.Record.account)
  return _s;
}
inline const std::string& Record::_internal_account() const {
  return account_.Get();
}
inline void Record::_internal_set_account(const std::string& value) {
  
  account_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_account() {
  
  return account_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_account() {
  // @@protoc_insertion_point(field_release:transfer.Record.account)
  return account_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_account(std::string* account) {
  if (account != nullptr) {
    
  } else {
    
  }
  account_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), account,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (account_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    account_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.account)
}

// string operation = 3;
inline void Record::clear_operation() {
  operation_.ClearToEmpty();
}
inline const std::string& Record::operation() const {
  // @@protoc_insertion_point(field_get:transfer.Record.operation)
  return _internal_operation();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_operation(ArgT0&& arg0, ArgT... args) {
 
 operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.operation)
}
inline std::string* Record::mutable_operation() {
  std::string* _s = _internal_mutable_operation();
  // @@protoc_insertion_point(field_mutable:transfer.Record.operation)
  return _s;
}
inline const std::string& Record::_internal_operation() const {
  return operation_.Get();
}
inline void Record::_internal_set_operation(const std::string& value) {
  
  operation_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_operation() {
  
  return operation_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_operation() {
  // @@protoc_insertion_point(field_release:transfer.Record.operation)
  return operation_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_operation(std::string* operation) {
  if (operation != nullptr) {
    
  } else {
    
  }
  operation_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operation,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operation_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operation_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.operation)
}

// string targetAccount = 4;
inline void Record::clear_targetaccount() {
  targetaccount_.ClearToEmpty();
}
inline const std::string& Record::targetaccount() const {
  // @@protoc_insertion_point(field_get:transfer.Record.targetAccount)
  return _internal_targetaccount();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_targetaccount(ArgT0&& arg0, ArgT... args) {
 
 targetaccount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.targetAccount)
}
inline std::string* Record::mutable_targetaccount() {
  std::string* _s = _internal_mutable_targetaccount();
  // @@protoc_insertion_point(field_mutable:transfer.Record.targetAccount)
  return _s;
}
inline const std::string& Record::_internal_targetaccount() const {
  return targetaccount_.Get();
}
inline void Record::_internal_set_targetaccount(const std::string& value) {
  
  targetaccount_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_targetaccount() {
  
  return targetaccount_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_targetaccount() {
  // @@protoc_insertion_point(field_release:transfer.Record.targetAccount)
  return targetaccount_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_targetaccount(std::string* targetaccount) {
  if (targetaccount != nullptr) {
    
  } else {
    
  }
  targetaccount_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), targetaccount,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (targetaccount_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    targetaccount_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.targetAccount)
}

// string nickname = 5;
inline void Record::clear_nickname() {
  nickname_.ClearToEmpty();
}
inline const std::string& Record::nickname() const {
  // @@protoc_insertion_point(field_get:transfer.Record.nickname)
  return _internal_nickname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_nickname(ArgT0&& arg0, ArgT... args) {
 
 nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.nickname)
}
inline std::string* Record::mutable_nickname() {
  std::string* _s = _internal_mutable_nickname();
  // @@protoc_insertion_point(field_mutable:transfer.Record.nickname)
  return _s;
}
inline const std::string& Record::_internal_nickname() const {
  return nickname_.Get();
}
inline void Record::_internal_set_nickname(const std::string& value) {
  
  nickname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_nickname() {
  
  return nickname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_nickname() {
  // @@protoc_insertion_point(field_release:transfer.Record.nickname)
  return nickname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_nickname(std::string* nickname) {
  if (nickname != nullptr) {
    
  } else {
    
  }
  nickname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nickname,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nickname_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nickname_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.nickname)
}

// string fileName = 6;
inline void Record::clear_filename() {
  filename_.ClearToEmpty();
}
inline const std::string& Record::filename() const {
  // @@protoc_insertion_point(field_get:transfer.Record.fileName)
  return _internal_filename();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_filename(ArgT0&& arg0, ArgT... args) {
 
 filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.fileName)
}
inline std::string* Record::mutable_filename() {
  std::string* _s = _internal_mutable_filename();
  // @@protoc_insertion_point(field_mutable:transfer.Record.fileName)
  return _s;
}
inline const std::string& Record::_internal_filename() const {
  return filename_.Get();
}
inline void Record::_internal_set_filename(const std::string& value) {
  
  filename_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_filename() {
  
  return filename_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_filename() {
  // @@protoc_insertion_point(field_release:transfer.Record.fileName)
  return filename_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_filename(std::string* filename) {
  if (filename != nullptr) {
    
  } else {
    
  }
  filename_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filename,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filename_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filename_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.fileName)
}

// uint64 fileSize = 7;
inline void Record::clear_filesize() {
  filesize_ = uint64_t{0u};
}
inline uint64_t Record::_internal_filesize() const {
  return filesize_;
}
inline uint64_t Record::filesize() const {
  // @@protoc_insertion_point(field_get:transfer.Record.fileSize)
  return _internal_filesize();
}
inline void Record::_internal_set_filesize(uint64_t value) {
  
  filesize_ = value;
}
inline void Record::set_filesize(uint64_t value) {
  _internal_set_filesize(value);
  // @@protoc_insertion_point(field_set:transfer.Record.fileSize)
}

// string fileCode = 8;
inline void Record::clear_filecode() {
  filecode_.ClearToEmpty();
}
inline const std::string& Record::filecode() const {
  // @@protoc_insertion_point(field_get:transfer.Record.fileCode)
  return _internal_filecode();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_filecode(ArgT0&& arg0, ArgT... args) {
 
 filecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.fileCode)
}
inline std::string* Record::mutable_filecode() {
  std::string* _s = _internal_mutable_filecode();
  // @@protoc_insertion_point(field_mutable:transfer.Record.fileCode)
  return _s;
}
inline const std::string& Record::_internal_filecode() const {
  return filecode_.Get();
}
inline void Record::_internal_set_filecode(const std::string& value) {
  
  filecode_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_filecode() {
  
  return filecode_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_filecode() {
  // @@protoc_insertion_point(field_release:transfer.Record.fileCode)
  return filecode_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_filecode(std::string* filecode) {
  if (filecode != nullptr) {
    
  } else {
    
  }
  filecode_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), filecode,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (filecode_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    filecode_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.fileCode)
}

// string operateTime = 9;
inline void Record::clear_operatetime() {
  operatetime_.ClearToEmpty();
}
inline const std::string& Record::operatetime() const {
  // @@protoc_insertion_point(field_get:transfer.Record.operateTime)
  return _internal_operatetime();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Record::set_operatetime(ArgT0&& arg0, ArgT... args) {
 
 operatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:transfer.Record.operateTime)
}
inline std::string* Record::mutable_operatetime() {
  std::string* _s = _internal_mutable_operatetime();
  // @@protoc_insertion_point(field_mutable:transfer.Record.operateTime)
  return _s;
}
inline const std::string& Record::_internal_operatetime() const {
  return operatetime_.Get();
}
inline void Record::_internal_set_operatetime(const std::string& value) {
  
  operatetime_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Record::_internal_mutable_operatetime() {
  
  return operatetime_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Record::release_operatetime() {
  // @@protoc_insertion_point(field_release:transfer.Record.operateTime)
  return operatetime_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Record::set_allocated_operatetime(std::string* operatetime) {
  if (operatetime != nullptr) {
    
  } else {
    
  }
  operatetime_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), operatetime,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (operatetime_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    operatetime_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:transfer.Record.operateTime)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace transfer

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_transfer_2eproto
